//! Generated by `sourcegen_ast`, do not edit by hand.

#![allow(bad_style, missing_docs, unreachable_pub)]
#[doc = r" The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT`."]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
#[repr(u16)]
pub enum SyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,
    COMMA,
    L_PAREN,
    R_PAREN,
    L_CURLY,
    R_CURLY,
    L_BRACK,
    R_BRACK,
    POUND,
    AMP,
    PLUS,
    EQ,
    EXCLA,
    LET_KW,
    EXPORT_KW,
    PUB_KW,
    CFG_KW,
    RULE_KW,
    STRING,
    ERROR,
    IDENT,
    WHITESPACE,
    COMMENT,
    SHEBANG,
    SOURCE_FILE,
    RULE,
    ARRAY_EXPR,
    BLOCK_EXPR,
    STMT_LIST,
    LET_EXPR,
    SHELL_EXPR,
    ATTR,
    LITERAL,
    VISIBILITY,
    NAME,
    LET_ELSE,
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;
impl SyntaxKind {
    pub fn is_keyword(self) -> bool {
        matches!(self, LET_KW | EXPORT_KW | PUB_KW | CFG_KW | RULE_KW)
    }
    pub fn is_punct(self) -> bool {
        matches!(
            self,
            COMMA
                | L_PAREN
                | R_PAREN
                | L_CURLY
                | R_CURLY
                | L_BRACK
                | R_BRACK
                | POUND
                | AMP
                | PLUS
                | EQ
                | EXCLA
        )
    }
    pub fn is_literal(self) -> bool { matches!(self, STRING) }
    pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "let" => LET_KW,
            "export" => EXPORT_KW,
            "pub" => PUB_KW,
            "cfg" => CFG_KW,
            "rule" => RULE_KW,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_contextual_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            ',' => COMMA,
            '(' => L_PAREN,
            ')' => R_PAREN,
            '{' => L_CURLY,
            '}' => R_CURLY,
            '[' => L_BRACK,
            ']' => R_BRACK,
            '#' => POUND,
            '&' => AMP,
            '+' => PLUS,
            '=' => EQ,
            '!' => EXCLA,
            _ => return None,
        };
        Some(tok)
    }
}
#[macro_export]
macro_rules ! T { [,] => { $ crate :: SyntaxKind :: COMMA } ; ['('] => { $ crate :: SyntaxKind :: L_PAREN } ; [')'] => { $ crate :: SyntaxKind :: R_PAREN } ; ['{'] => { $ crate :: SyntaxKind :: L_CURLY } ; ['}'] => { $ crate :: SyntaxKind :: R_CURLY } ; ['['] => { $ crate :: SyntaxKind :: L_BRACK } ; [']'] => { $ crate :: SyntaxKind :: R_BRACK } ; [#] => { $ crate :: SyntaxKind :: POUND } ; [&] => { $ crate :: SyntaxKind :: AMP } ; [+] => { $ crate :: SyntaxKind :: PLUS } ; [=] => { $ crate :: SyntaxKind :: EQ } ; [!] => { $ crate :: SyntaxKind :: EXCLA } ; [let] => { $ crate :: SyntaxKind :: LET_KW } ; [export] => { $ crate :: SyntaxKind :: EXPORT_KW } ; [pub] => { $ crate :: SyntaxKind :: PUB_KW } ; [cfg] => { $ crate :: SyntaxKind :: CFG_KW } ; [rule] => { $ crate :: SyntaxKind :: RULE_KW } ; [lifetime_ident] => { $ crate :: SyntaxKind :: LIFETIME_IDENT } ; [ident] => { $ crate :: SyntaxKind :: IDENT } ; [shebang] => { $ crate :: SyntaxKind :: SHEBANG } ; }
